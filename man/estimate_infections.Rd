% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_infections.R
\name{estimate_infections}
\alias{estimate_infections}
\title{Estimate Infections, the Time-Varying Reproduction Number and the Rate of Growth}
\usage{
estimate_infections(
  reported_cases,
  generation_time,
  delays = list(),
  rt = list(),
  gp = list(),
  obs_model = list(),
  stan_args = list(),
  horizon = 7,
  samples = 1000,
  prior_smoothing_window = 7,
  CrIs = c(0.2, 0.5, 0.9),
  future = FALSE,
  max_execution_time = Inf,
  return_fit = TRUE,
  id = "estimate_infections",
  verbose = interactive()
)
}
\arguments{
\item{reported_cases}{A data frame of confirmed cases (confirm) by date (date). confirm must be integer and date must be
in date format.}

\item{generation_time}{A list containing the mean, standard deviation of the mean (mean_sd),
standard deviation (sd), standard deviation of the standard deviation and the maximum allowed value for the
generation time (assuming a gamma distribution).}

\item{delays}{A list of delays (i.e incubation period/reporting delay) between infection and report.
Each list entry must also be a list containing the mean, standard deviation of the mean (mean_sd),
standard deviation (sd), standard deviation of the standard deviation and the maximum allowed value for the
that delay (assuming a lognormal distribution with all parameters excepting the max allowed value
on the log scale). To use no delays set this to \code{list()}.}

\item{rt}{Logical, defaults to \code{TRUE}. Is Rt being estimated? This controls Rt
specific Gaussian process settings that are not supported for back calculation.}

\item{gp}{A list of settings to override the package default Gaussian
process settings. See the documentation for \code{gp_settings} for details of these
settings and \code{gp_settings()} for the current defaults.}

\item{obs_model}{A list of settings to override the package default observation
model settings. See the documentation for \code{obs_model_settings} for details of these
settings and \code{obs_model_settings()} for the current defaults.}

\item{stan_args}{A list of settings to override the package default stan settings. See the documentation
for \code{create_stan_args} for details and \code{create_stan_args()} for current defaults.}

\item{horizon}{Numeric, defaults to 7. Number of days into the future to forecast.}

\item{samples}{Numeric, defaults to 1000. Number of samples post warmup.}

\item{prior_smoothing_window}{Numeric defaults to 7. The number of days over which to take a rolling average
for the prior based on reported cases. Used for back calculation only.}

\item{CrIs}{Numeric vector of credible intervals to calculate.}

\item{future}{Logical, defaults to \code{FALSE}. Should stan chains be run in parallel using \code{future}. This allows users to have chains
fail gracefully (i.e when combined with \code{max_execution_time}). Should be combined with a call to \code{future::plan}}

\item{max_execution_time}{Numeric, defaults to Inf (seconds). If set will kill off processing of each chain if not finished within the specified timeout.
When more than 2 chains finish successfully estimates will still be returned. If less than 2 chains return within the allowed time then estimation
will fail with an informative error.}

\item{return_fit}{Logical, defaults to TRUE. Should the fitted stan model be returned.}

\item{id}{A character string used to assign logging information on error. Used by \code{regional_epinow}
to assign errors to regions. Alter the default to run with error catching.}

\item{verbose}{Logical, defaults to \code{TRUE} when used interactively and otherwise \code{FALSE}. Should verbose debug progress messages be printed. Corresponds to the "DEBUG" level from
\code{futile.logger}. See \code{setup_logging} for more detailed logging options.}

\item{rt_prior}{A list contain the mean and standard deviation (sd) of the lognormal prior for Rt. By default this is assumed to be mean 1 with a standard deviation of 1 (note in model these will be mapped to
log space). To infer infections and then calculate Rt using backcalculation set this to \code{list()}.}

\item{use_breakpoints}{Logical, defaults to TRUE but only active if a \code{breakpoint} variable is present in the input data.
Breakpoints should be defined as 1 if present and otherwise 0. By default breakpoints are fit jointly with
a global non-parametric effect and so represent a conservative estimate of breakpoint changes. To specify a random walk define
breakpoints every n days (so every 7 days for a weekly random walk) and disable the gaussian process using \code{gp = list()}.}

\item{burn_in}{Numeric, defaults to 0. The number of initial Rt estimates to discard. This argument is depreciated and will be
removed from the package unless a clear user need is given.}
}
\description{
This function uses a non-parametric approach to reconstruct cases by date of infection from reported
cases. It uses either a generative Rt model or non-parametric back calculation to estimate underlying
latent infections and then maps these infections to observed cases via uncertain reporting delays and a flexible
observation model. See the examples and function arguments for the details of all options. The default settings
may not be sufficient for your use case so the number of warmup samples (\code{stan_args = list(warmup)}) may need to
be increased as may the overall number of samples. Follow the links provided by any warnings messages to diagnose
issues with the MCMC fit.
}
\examples{
\donttest{
# get example case counts
reported_cases <- EpiNow2::example_confirmed[1:60]

# set up example generation time
generation_time <- get_generation_time(disease = "SARS-CoV-2", source = "ganyani")
# set delays between infection and case report 
incubation_period <- get_incubation_period(disease = "SARS-CoV-2", source = "lauer")
reporting_delay <- list(mean = convert_to_logmean(3, 1), 
                        mean_sd = 0.1,
                        sd = convert_to_logsd(3, 1), 
                        sd_sd = 0.1, 
                        max = 15)
      
# default setting
def <- estimate_infections(reported_cases, generation_time = generation_time,
                           delays = list(incubation_period, reporting_delay),
                           rt = list(prior = list(mean = 2, sd = 0.2)),
                           stan_args = list(cores = ifelse(interactive(), 4, 1)))
 summary(def)
 plot(def)

# run model using backcalculation (combined here with under reporting)
backcalc <- estimate_infections(reported_cases, generation_time = generation_time,
                                delays = list(incubation_period, reporting_delay),
                                rt = NULL,
                                obs_model = list(scale = list(mean = 0.4, sd = 0.01)),
                                stan_args = list(cores = ifelse(interactive(), 4, 1)))
plot(backcalc)
                           
# Rt projected into the future using the Gaussian process
project_rt <- estimate_infections(reported_cases, generation_time = generation_time,
                                  delays = list(incubation_period, reporting_delay),
                                  rt = list(prior = list(mean = 2, sd = 0.2)),
                                  gp = list(future = "project"),
                                  stan_args = list(cores = ifelse(interactive(), 4, 1)))
plot(project_rt)

# default settings on a later snapshot of data 
snapshot_cases <- EpiNow2::example_confirmed[80:130]
snapshot <- estimate_infections(snapshot_cases, generation_time = generation_time,
                                delays = list(incubation_period, reporting_delay),
                                rt = list(prior = list(mean = 1, sd = 0.2)),
                                stan_args = list(cores = ifelse(interactive(), 4, 1)))
plot(snapshot) 

# stationary Rt assumption (likely to provide biased real-time estimates)
stat <- estimate_infections(reported_cases, generation_time = generation_time,
                            delays = list(incubation_period, reporting_delay),
                            gp = list(stationary = TRUE),
                            rt = list(prior = list(mean = 2, sd = 0.2)),
                            stan_args = list(cores = ifelse(interactive(), 4, 1)))
plot(stat)
       
# no gaussian process (i.e fixed Rt assuming no breakpoints)
fixed <- estimate_infections(reported_cases, generation_time = generation_time,
                             delays = list(incubation_period, reporting_delay),
                             gp = NULL,
                             stan_args = list(cores = ifelse(interactive(), 4, 1)))
plot(fixed)

# no delays 
no_delay <- estimate_infections(reported_cases, generation_time = generation_time,
                                stan_args = list(cores = ifelse(interactive(), 4, 1)))
plot(no_delay)    

# breakpoints but otherwise static Rt
bp_cases <- data.table::copy(reported_cases)
bp_cases <- bp_cases[, breakpoint := ifelse(date == as.Date("2020-03-16"), 1, 0)]
bkp <- estimate_infections(bp_cases, generation_time = generation_time,
                           delays = list(incubation_period, reporting_delay),
                           rt = list(prior = list(mean = 2, sd = 0.2)),
                           stan_args = list(object = model, cores = ifelse(interactive(), 4, 1)),
                           gp = NULL)                                                         
# breakpoint effect
summary(bkp, type = "parameters", params = "breakpoints")
plot(bkp)


# weekly random walk
rw <- estimate_infections(reported_cases, generation_time = generation_time,
                          delays = list(incubation_period, reporting_delay),
                          rt = list(prior = list(mean = 2, sd = 0.2), rw = 7),
                          stan_args = list(cores = ifelse(interactive(), 4, 1)),
                          gp = NULL)     

# breakpoint effects
summary(rw, type = "parameters", params = "breakpoints")                                                    
plot(rw)
}                                
}
