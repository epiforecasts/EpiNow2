% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_secondary.R
\name{estimate_secondary}
\alias{estimate_secondary}
\title{Estimate a Secondary Observation from a Primary Observation}
\usage{
estimate_secondary(
  reports,
  secondary = secondary_opts(),
  delays = delay_opts(list(mean = 2.5, mean_sd = 1, sd = 0.47, sd_sd = 1, max = 30)),
  truncation = trunc_opts(),
  obs = obs_opts(),
  CrIs = c(0.2, 0.5, 0.9),
  model = NULL,
  verbose = interactive(),
  ...
)
}
\arguments{
\item{reports}{A data frame containing the \code{date} of report and both \code{primary}
and \code{secondary} reports.}

\item{secondary}{A call to \code{secondary_opts()} or a list containing the following
binary variables: cumulative, historic, primary_hist_additive, current,
primary_current_additive. These parameters control the structure of the
secondary model, see \code{secondary_opts()} for details.}

\item{delays}{A call to \code{delay_opts()} defining delay distributions between
primary and secondary observations See the documentation of \code{delay_opts()} for
details. BY default a diffuse prior  is assumed with a mean of 14 days and
standard deviation of 7 days (both with a standard deviation of 1 on the log scale).}

\item{truncation}{\ifelse{html}{\out{<a href='https://www.tidyverse.org/lifecycle/#experimental'><img src='figures/lifecycle-experimental.svg' alt='Experimental lifecycle'></a>}}{\strong{Experimental}} A list of options as generated by \code{trunc_opts()}
defining the truncation of observed data. Defaults to \code{trunc_opts()}. See \code{estimate_truncation()}
for an approach to estimating truncation from data.}

\item{obs}{A list of options as generated by \code{obs_opts()} defining the
observation model. Defaults to \code{obs_opts()}.}

\item{CrIs}{Numeric vector of credible intervals to calculate.}

\item{model}{A compiled stan model to override the default model. May be
useful for package developers or those developing extensions.}

\item{verbose}{Logical, should model fitting progress be returned. Defaults to
\code{interactive()}.}

\item{...}{Additional parameters to pass to \code{rstan::sampling}.}
}
\value{

}
\description{
\ifelse{html}{\out{<a href='https://www.tidyverse.org/lifecycle/#experimental'><img src='figures/lifecycle-experimental.svg' alt='Experimental lifecycle'></a>}}{\strong{Experimental}}
Estimates the relationship between a primary and secondary observation, for
example hospital admissions and deaths or hospital admissions and bed
occupancy. See \code{secondary_opts()} for model structure options. See parameter
documentation for model defaults and options.
}
\examples{
#set number of cores to use
options(mc.cores = ifelse(interactive(), 4, 1))
# load data.table for manipulation
library(data.table)
# make some example secondary incidence data
cases <- example_confirmed
cases <- as.data.table(cases)
cases <- cases[, .(date, primary = confirm, secondary = shift(confirm, n = 7, type = "lag"))]
cases <- cases[, secondary := frollmean(secondary, 3, align = "right")]
cases <- cases[!is.na(secondary)][, secondary := as.integer(secondary)]

# dev model compile
model <- rstan::stan_model("inst/stan/estimate_secondary.stan")

# fit model to example data
inc <- estimate_secondary(cases, verbose = interactive(), model = model,
                          chains = 2, iter = 1000)
plot(inc, primary = TRUE)
\donttest{
# make some example prevalence data
cases <- example_confirmed
cases <- as.data.table(cases)
cases <- 
  cases[, .(date, primary = confirm, 
                  scaled_primary = confirm * rnorm(.N, 0.2, 0.05))]
cases$secondary <- 0
cases$secondary[1] <- as.integer(cases$scaled_primary[1))
for (i in 2:nrow(cases)) {
  cmf <- cumsum(dlnorm(1:min(i-1,10), rnorm(1, 1.3, 0.05), 0.4)) - 
           cumsum(dlnorm(0:min(9,i-2), rnorm(1, 1.3, 0.05), 0.4))
  cases$secondary[i] <- as.integer(
  cases$secondary[i -1] + cases$scaled_primary[i] - 
        sum(cases$scaled_primary[(i-1):max(1,i-10)] * cmf)) 
  cases$secondary[i] <- ifelse(cases$secondary[i] < 0, 0,
                               cases$secondary[i])
}
# fit model to example prevalence data
# here we assume no day of the week effect and a Poisson observation model
# this is motivated by the expected level of auto-correlation in cumulative
prev <- estimate_secondary(cases, verbose = interactive(), model = model,
                          secondary = secondary_opts(type = "prevalence"),
                          obs = obs_opts(week_effect = FALSE, family = "poisson",
                                         scale = list(mean = 0.1, sd = 0.1)))
plot(prev)
}
}
