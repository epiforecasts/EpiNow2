---
title: "Getting started with EpiNow2"
output:
  rmarkdown::html_vignette:
    toc: false
    number_sections: false
bibliography: library.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-numeric-superscript-brackets.csl
vignette: >
  %\VignetteIndexEntry{Getting started with EpiNow2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


## Quick start

In the following section we give an overview of the simple use case for `epinow()` and `regional_epinow()`.

The first step to using the package is to load it as follows.


``` r
library(EpiNow2)
```

### Reporting delays, incubation period and generation time

Distributions can be supplied in two ways. First, one can supplying delay data to `estimate_delay()`, where a subsampled bootstrapped lognormal will be fit to account for uncertainty in the observed data without being biased by changes in incidence (see `?EpiNow2::estimate_delay()`).

Second, one can specify predetermined delays with uncertainty using the distribution functions such as `Gamma` or `Lognormal`. An arbitrary number of delay distributions are supported in `dist_spec()` with a common use case being an incubation period followed by a reporting delay. For more information on specifying distributions see (see `?EpiNow2::Distributions`).

For example if data on the delay between onset and infection was available we could fit a distribution to it, using `estimate_delay()`, with appropriate uncertainty as follows (note this is a synthetic example),

``` r
reporting_delay <- estimate_delay(
  rlnorm(1000, log(2), 1),
  max_value = 14, bootstraps = 1
)
```

If data was not available we could instead specify an informed estimate of the likely delay using the distribution functions `Gamma` or `LogNormal`. 
To demonstrate, we choose a lognormal distribution with mean 2, standard deviation 1 and a maximum of 10. *This is just an example and unlikely to apply in any particular use case*.


``` r
reporting_delay <- LogNormal(mean = 2, sd = 1, max = 10)
reporting_delay
#> - lognormal distribution (max: 10):
#>   meanlog:
#>     0.58
#>   sdlog:
#>     0.47
```

For the rest of this vignette, we will use inbuilt example literature estimates for the incubation period and generation time of Covid-19 (see [here](https://github.com/epiforecasts/EpiNow2/tree/main/data-raw) for the code that generates these estimates). *These distributions are unlikely to be applicable for your use case. We strongly recommend investigating what might be the best distributions to use in any given use case.*


``` r
example_generation_time
#> - gamma distribution (max: 14):
#>   shape:
#>     - normal distribution:
#>       mean:
#>         1.4
#>       sd:
#>         0.48
#>   rate:
#>     - normal distribution:
#>       mean:
#>         0.38
#>       sd:
#>         0.25
example_incubation_period
#> - lognormal distribution (max: 14):
#>   meanlog:
#>     - normal distribution:
#>       mean:
#>         1.6
#>       sd:
#>         0.064
#>   sdlog:
#>     - normal distribution:
#>       mean:
#>         0.42
#>       sd:
#>         0.069
```

Now, to the functions.

### [epinow()](https://epiforecasts.io/EpiNow2/reference/epinow.html)

This function represents the core functionality of the package and includes results reporting, plotting, and optional saving. It requires a data frame of cases by date of report and the distributions defined above.

Load example case data from `{EpiNow2}`.


``` r
reported_cases <- example_confirmed[1:60]
head(reported_cases)
#>          date confirm
#>        <Date>   <num>
#> 1: 2020-02-22      14
#> 2: 2020-02-23      62
#> 3: 2020-02-24      53
#> 4: 2020-02-25      97
#> 5: 2020-02-26      93
#> 6: 2020-02-27      78
```

Estimate cases by date of infection, the time-varying reproduction number, the rate of growth, and forecast these estimates into the future by 7 days. Summarise the posterior and return a summary table and plots for reporting purposes. If a `target_folder` is supplied results can be internally saved (with the option to also turn off explicit returning of results). Here we use the default model parameterisation that prioritises real-time performance over run-time or other considerations. For other formulations see the documentation for `estimate_infections()`.


``` r
estimates <- epinow(
  data = reported_cases,
  generation_time = gt_opts(example_generation_time),
  delays = delay_opts(example_incubation_period + reporting_delay),
  rt = rt_opts(prior = list(mean = 2, sd = 0.2)),
  stan = stan_opts(cores = 4, control = list(adapt_delta = 0.99), backend = "cmdstanr"),
  verbose = interactive()
)
#> WARN [2024-08-12 18:42:26] epinow: The `matern_type` argument of `gp_opts()` is deprecated as of EpiNow2 1.6.0. - 
#> DEBUG [2024-08-12 18:43:07] epinow: Running in exact mode for  samples (across 4 chains each with a warm up of  iterations each) and 81 time steps of which 7 are a forecast
#> Running MCMC with 4 parallel chains...
#> 
#> Chain 1 Iteration:   1 / 750 [  0%]  (Warmup) 
#> Chain 2 Iteration:   1 / 750 [  0%]  (Warmup) 
#> Chain 3 Iteration:   1 / 750 [  0%]  (Warmup) 
#> Chain 4 Iteration:   1 / 750 [  0%]  (Warmup) 
#> Chain 2 Iteration:  50 / 750 [  6%]  (Warmup) 
#> Chain 1 Iteration:  50 / 750 [  6%]  (Warmup) 
#> Chain 2 Iteration: 100 / 750 [ 13%]  (Warmup) 
#> Chain 4 Iteration:  50 / 750 [  6%]  (Warmup) 
#> Chain 2 Iteration: 150 / 750 [ 20%]  (Warmup) 
#> Chain 2 Iteration: 200 / 750 [ 26%]  (Warmup) 
#> Chain 2 Iteration: 250 / 750 [ 33%]  (Warmup) 
#> Chain 2 Iteration: 251 / 750 [ 33%]  (Sampling) 
#> Chain 2 Iteration: 300 / 750 [ 40%]  (Sampling) 
#> Chain 2 Iteration: 350 / 750 [ 46%]  (Sampling) 
#> Chain 3 Iteration:  50 / 750 [  6%]  (Warmup) 
#> Chain 2 Iteration: 400 / 750 [ 53%]  (Sampling) 
#> Chain 2 Iteration: 450 / 750 [ 60%]  (Sampling) 
#> Chain 2 Iteration: 500 / 750 [ 66%]  (Sampling) 
#> Chain 2 Iteration: 550 / 750 [ 73%]  (Sampling) 
#> Chain 2 Iteration: 600 / 750 [ 80%]  (Sampling) 
#> Chain 1 Iteration: 100 / 750 [ 13%]  (Warmup) 
#> Chain 2 Iteration: 650 / 750 [ 86%]  (Sampling) 
#> Chain 1 Iteration: 150 / 750 [ 20%]  (Warmup) 
#> Chain 1 Iteration: 200 / 750 [ 26%]  (Warmup) 
#> Chain 2 Iteration: 700 / 750 [ 93%]  (Sampling) 
#> Chain 1 Iteration: 250 / 750 [ 33%]  (Warmup) 
#> Chain 1 Iteration: 251 / 750 [ 33%]  (Sampling) 
#> Chain 2 Iteration: 750 / 750 [100%]  (Sampling) 
#> Chain 2 finished in 9.3 seconds.
#> Chain 1 Iteration: 300 / 750 [ 40%]  (Sampling) 
#> Chain 1 Iteration: 350 / 750 [ 46%]  (Sampling) 
#> Chain 1 Iteration: 400 / 750 [ 53%]  (Sampling) 
#> Chain 4 Iteration: 100 / 750 [ 13%]  (Warmup) 
#> Chain 1 Iteration: 450 / 750 [ 60%]  (Sampling) 
#> Chain 4 Iteration: 150 / 750 [ 20%]  (Warmup) 
#> Chain 4 Iteration: 200 / 750 [ 26%]  (Warmup) 
#> Chain 1 Iteration: 500 / 750 [ 66%]  (Sampling) 
#> Chain 1 Iteration: 550 / 750 [ 73%]  (Sampling) 
#> Chain 1 Iteration: 600 / 750 [ 80%]  (Sampling) 
#> Chain 4 Iteration: 250 / 750 [ 33%]  (Warmup) 
#> Chain 4 Iteration: 251 / 750 [ 33%]  (Sampling) 
#> Chain 1 Iteration: 650 / 750 [ 86%]  (Sampling) 
#> Chain 1 Iteration: 700 / 750 [ 93%]  (Sampling) 
#> Chain 3 Iteration: 100 / 750 [ 13%]  (Warmup) 
#> Chain 4 Iteration: 300 / 750 [ 40%]  (Sampling) 
#> Chain 1 Iteration: 750 / 750 [100%]  (Sampling) 
#> Chain 1 finished in 10.8 seconds.
#> Chain 3 Iteration: 150 / 750 [ 20%]  (Warmup) 
#> Chain 4 Iteration: 350 / 750 [ 46%]  (Sampling) 
#> Chain 3 Iteration: 200 / 750 [ 26%]  (Warmup) 
#> Chain 4 Iteration: 400 / 750 [ 53%]  (Sampling) 
#> Chain 3 Iteration: 250 / 750 [ 33%]  (Warmup) 
#> Chain 3 Iteration: 251 / 750 [ 33%]  (Sampling) 
#> Chain 4 Iteration: 450 / 750 [ 60%]  (Sampling) 
#> Chain 3 Iteration: 300 / 750 [ 40%]  (Sampling) 
#> Chain 4 Iteration: 500 / 750 [ 66%]  (Sampling) 
#> Chain 3 Iteration: 350 / 750 [ 46%]  (Sampling) 
#> Chain 4 Iteration: 550 / 750 [ 73%]  (Sampling) 
#> Chain 3 Iteration: 400 / 750 [ 53%]  (Sampling) 
#> Chain 4 Iteration: 600 / 750 [ 80%]  (Sampling) 
#> Chain 3 Iteration: 450 / 750 [ 60%]  (Sampling) 
#> Chain 4 Iteration: 650 / 750 [ 86%]  (Sampling) 
#> Chain 3 Iteration: 500 / 750 [ 66%]  (Sampling) 
#> Chain 4 Iteration: 700 / 750 [ 93%]  (Sampling) 
#> Chain 3 Iteration: 550 / 750 [ 73%]  (Sampling) 
#> Chain 4 Iteration: 750 / 750 [100%]  (Sampling) 
#> Chain 4 finished in 12.8 seconds.
#> Chain 3 Iteration: 600 / 750 [ 80%]  (Sampling) 
#> Chain 3 Iteration: 650 / 750 [ 86%]  (Sampling) 
#> Chain 3 Iteration: 700 / 750 [ 93%]  (Sampling) 
#> Chain 3 Iteration: 750 / 750 [100%]  (Sampling) 
#> Chain 3 finished in 13.8 seconds.
#> 
#> All 4 chains finished successfully.
#> Mean chain execution time: 11.7 seconds.
#> Total execution time: 14.0 seconds.
names(estimates)
#> [1] "estimates"                "estimated_reported_cases"
#> [3] "summary"                  "plots"                   
#> [5] "timing"
```

Both summary measures and posterior samples are returned for all parameters in an easily explored format which can be accessed using `summary`. The default is to return a summary table of estimates for key parameters at the latest date partially supported by data. 


``` r
knitr::kable(summary(estimates))
```



|measure                          |estimate               |
|:--------------------------------|:----------------------|
|New infections per day           |29451 (16547 -- 55914) |
|Expected change in daily reports |Increasing             |
|Effective reproduction no.       |1.3 (1.2 -- 1.4)       |
|Rate of growth                   |0.065 (0.05 -- 0.081)  |
|Doubling/halving time (days)     |11 (8.6 -- 14)         |



Summarised parameter estimates can also easily be returned, either filtered for a single parameter or for all parameters.


``` r
head(summary(estimates, type = "parameters", params = "R"))
#>          date variable  strat     type   median     mean
#>        <Date>   <char> <char>   <char>    <num>    <num>
#> 1: 2020-02-22        R   <NA> estimate 1.279225 1.282726
#> 2: 2020-02-23        R   <NA> estimate 1.278850 1.282762
#> 3: 2020-02-24        R   <NA> estimate 1.279225 1.282726
#> 4: 2020-02-25        R   <NA> estimate 1.279620 1.282590
#> 5: 2020-02-26        R   <NA> estimate 1.279320 1.282550
#> 6: 2020-02-27        R   <NA> estimate 1.279620 1.282590
#>            sd lower_90 lower_50 lower_20 upper_20 upper_50
#>         <num>    <num>    <num>    <num>    <num>    <num>
#> 1: 0.05200542 1.204985 1.246333 1.266616 1.292832 1.314027
#> 2: 0.05209763 1.204978 1.246053 1.266656 1.292378 1.314353
#> 3: 0.05200542 1.204985 1.246333 1.266616 1.292832 1.314027
#> 4: 0.05197728 1.204885 1.246422 1.267060 1.292698 1.313692
#> 5: 0.05203290 1.204938 1.246128 1.267008 1.292536 1.313650
#> 6: 0.05197728 1.204885 1.246422 1.267060 1.292698 1.313692
#>    upper_90
#>       <num>
#> 1: 1.374642
#> 2: 1.374307
#> 3: 1.374642
#> 4: 1.373742
#> 5: 1.373585
#> 6: 1.373742
```

Reported cases are returned in a separate data frame in order to streamline the reporting of forecasts and for model evaluation.


``` r
head(summary(estimates, output = "estimated_reported_cases"))
#>          date   type median     mean       sd lower_90 lower_50
#>        <Date> <char>  <num>    <num>    <num>    <num>    <num>
#> 1: 2020-02-22  gp_rt  206.0 271.6535 255.3386    23.00    99.75
#> 2: 2020-02-23  gp_rt  263.0 367.7565 358.6296    35.95   128.00
#> 3: 2020-02-24  gp_rt  276.5 380.0340 360.5072    34.00   129.00
#> 4: 2020-02-25  gp_rt  301.0 411.2625 398.3551    35.95   144.00
#> 5: 2020-02-26  gp_rt  312.0 445.8105 452.1032    36.00   149.00
#> 6: 2020-02-27  gp_rt  429.5 592.3665 550.8577    54.00   213.75
#>    lower_20 upper_20 upper_50 upper_90
#>       <num>    <num>    <num>    <num>
#> 1:    160.0    254.0   364.25   725.05
#> 2:    208.0    328.4   485.00  1067.15
#> 3:    209.2    350.8   506.00  1095.45
#> 4:    233.0    376.0   554.50  1190.10
#> 5:    243.0    400.0   582.00  1307.25
#> 6:    336.0    544.8   803.25  1660.15
```

A range of plots are returned (with the single summary plot shown below). These plots can also be generated using the following `plot` method.


``` r
plot(estimates)
```

![plot of chunk unnamed-chunk-11](EpiNow2-unnamed-chunk-11-1.png)


### [regional_epinow()](https://epiforecasts.io/EpiNow2/reference/regional_epinow.html)

The `regional_epinow()` function runs the `epinow()` function across multiple regions in
an efficient manner.

Define cases in multiple regions delineated by the region variable.


``` r
reported_cases <- data.table::rbindlist(list(
  data.table::copy(reported_cases)[, region := "testland"],
  reported_cases[, region := "realland"]
))
head(reported_cases)
#>          date confirm   region
#>        <Date>   <num>   <char>
#> 1: 2020-02-22      14 testland
#> 2: 2020-02-23      62 testland
#> 3: 2020-02-24      53 testland
#> 4: 2020-02-25      97 testland
#> 5: 2020-02-26      93 testland
#> 6: 2020-02-27      78 testland
```

Calling `regional_epinow()` runs the `epinow()` on each region in turn (or in parallel depending on the settings used). Here we switch to using a weekly random walk rather than the full Gaussian process model giving us piecewise constant estimates by week.


``` r
estimates <- regional_epinow(
  data = reported_cases,
  generation_time = gt_opts(example_generation_time),
  delays = delay_opts(example_incubation_period + reporting_delay),
  rt = rt_opts(prior = list(mean = 2, sd = 0.2), rw = 7),
  gp = NULL,
  stan = stan_opts(cores = 4, warmup = 250, samples = 1000)
)
#> INFO [2024-08-12 18:43:26] Producing following optional outputs: regions, summary, samples, plots, latest
#> INFO [2024-08-12 18:43:27] Reporting estimates using data up to: 2020-04-21
#> INFO [2024-08-12 18:43:27] No target directory specified so returning output
#> INFO [2024-08-12 18:43:27] Producing estimates for: testland, realland
#> INFO [2024-08-12 18:43:27] Regions excluded: none
#> Error in eval(expr, envir, enclos) : 
#>   Exception: variable does not exist; processing stage=data initialization; variable name=delay_mean_mean; base type=double (in 'estimate_infections', line 613, column 2 to column 40)
#> Error in eval(expr, envir, enclos) : 
#>   Exception: variable does not exist; processing stage=data initialization; variable name=delay_mean_mean; base type=double (in 'estimate_infections', line 613, column 2 to column 40)
#> DEBUG [2024-08-12 18:43:27] testland: Running in exact mode for 1000 samples (across 4 chains each with a warm up of 250 iterations each) and 81 time steps of which 7 are a forecast
#> DEBUG [2024-08-12 18:43:27] realland: Running in exact mode for 1000 samples (across 4 chains each with a warm up of 250 iterations each) and 81 time steps of which 7 are a forecast
#> INFO [2024-08-12 18:43:28] Completed regional estimates
#> INFO [2024-08-12 18:43:28] Regions with estimates: 0
#> INFO [2024-08-12 18:43:28] Regions with runtime errors: 2
#> INFO [2024-08-12 18:43:28] Producing summary
#> INFO [2024-08-12 18:43:28] No summary directory specified so returning summary output
#> INFO [2024-08-12 18:43:28] Errors caught whilst generating summary statistics: 
#> INFO [2024-08-12 18:43:28] Error: Object 'variable' not found amongst []
#> 
#> INFO [2024-08-12 18:43:28] No target directory specified so returning timings
```

Results from each region are stored in a `regional` list with across region summary measures and plots stored in a `summary` list. All results can be set to be internally saved by setting the `target_folder` and `summary_dir` arguments. Each region can be estimated in parallel using the `{future}` package (when in most scenarios `cores` should be set to 1). For routine use each MCMC chain can also be run in parallel (with `future` = TRUE) with a time out (`max_execution_time`) allowing for partial results to be returned if a subset of chains is running longer than expected. See the documentation for the `{future}` package for details on nested futures.

Summary measures that are returned include a table formatted for reporting (along with raw results for further processing). Futures updated will extend the S3 methods used above to smooth access to this output.


``` r
knitr::kable(estimates$summary$summarised_results$table)
```






A range of plots are again returned (with the single summary plot shown below).


``` r
estimates$summary$summary_plot
#> NULL
```
